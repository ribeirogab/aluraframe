{"version":3,"sources":["../../src/util/ConnectionFactory.js"],"names":["connection","stores","close","ConnectionFactory","constructor","Error","getConnection","Promise","resolve","reject","openRequest","indexedDB","open","onupgradeneeded","e","_createStores","target","result","onsuccess","bind","onerror","console","log","error","name","forEach","store","objectStoreNames","contains","deleteObjectStore","createObjectStore","autoIncrement","closeConnection"],"mappings":";;;;;;AAAA,UAAIA,aAAa,IAAjB;AACA,YAAMC,SAAS,CAAC,QAAD,CAAf;AACA,UAAIC,QAAQ,IAAZ;;UAEaC,iB,GAAN,MAAMA,iBAAN,CAAwB;AAC7BC,sBAAc;AACZ,gBAAM,IAAIC,KAAJ,CAAU,oCAAV,CAAN;AACD;AACD,eAAOC,aAAP,GAAuB;AACrB,iBAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,kBAAMC,cAAcC,UAAUC,IAAV,CAAe,cAAf,EAA+B,CAA/B,CAApB;;AAEA,gBAAGZ,UAAH,EAAe,OAAOQ,QAAQR,UAAR,CAAP;;AAEfU,wBAAYG,eAAZ,GAA8BC,KAAK;AACjCX,gCAAkBY,aAAlB,CAAgCD,EAAEE,MAAF,CAASC,MAAzC;AACD,aAFD;;AAIAP,wBAAYQ,SAAZ,GAAwBJ,KAAK;AAC3Bd,2BAAac,EAAEE,MAAF,CAASC,MAAtB;AACAf,sBAAQF,WAAWE,KAAX,CAAiBiB,IAAjB,CAAsBnB,UAAtB,CAAR;AACAA,yBAAWE,KAAX,GAAmB,MAAM;AACvB,sBAAM,IAAIG,KAAJ,CAAU,4CAAV,CAAN;AACD,eAFD;AAGAG,sBAAQM,EAAEE,MAAF,CAASC,MAAjB;AACD,aAPD;;AASAP,wBAAYU,OAAZ,GAAsBN,KAAK;AACzBO,sBAAQC,GAAR,CAAYR,EAAEE,MAAF,CAASO,KAArB;AACAd,qBAAOK,EAAEE,MAAF,CAASO,KAAT,CAAeC,IAAtB;AACD,aAHD;AAID,WAtBM,CAAP;AAuBD;;AAED,eAAOT,aAAP,CAAqBf,UAArB,EAAiC;AAC/BC,iBAAOwB,OAAP,CAAeC,SAAS;AACtB,gBAAI1B,WAAW2B,gBAAX,CAA4BC,QAA5B,CAAqCF,KAArC,CAAJ,EAAiD;AAC/C1B,yBAAW6B,iBAAX,CAA6BH,KAA7B;AACD;AACD1B,uBAAW8B,iBAAX,CAA6BJ,KAA7B,EAAoC;AAClCK,6BAAe;AADmB,aAApC;AAGD,WAPD;AAQD;;AAED,eAAOC,eAAP,GAAwB;AACtB,cAAGhC,UAAH,EAAc;AACZE;AACD;AACF;AA7C4B,O","file":"ConnectionFactory.js","sourcesContent":["let connection = null\nconst stores = ['trades']\nlet close = null\n\nexport class ConnectionFactory {\n  constructor() {\n    throw new Error('This class cannot be instantiated!')\n  }\n  static getConnection() {\n    return new Promise((resolve, reject) => {\n      const openRequest = indexedDB.open('jscangaceiro', 1)\n\n      if(connection) return resolve(connection)\n\n      openRequest.onupgradeneeded = e => {\n        ConnectionFactory._createStores(e.target.result)\n      }\n\n      openRequest.onsuccess = e => {\n        connection = e.target.result\n        close = connection.close.bind(connection)\n        connection.close = () => {\n          throw new Error('You cannot directly close this connection!')\n        }\n        resolve(e.target.result)\n      }\n\n      openRequest.onerror = e => {\n        console.log(e.target.error)\n        reject(e.target.error.name)\n      }\n    })\n  }\n\n  static _createStores(connection) {\n    stores.forEach(store => {\n      if (connection.objectStoreNames.contains(store)) {\n        connection.deleteObjectStore(store)\n      }\n      connection.createObjectStore(store, {\n        autoIncrement: true\n      })\n    })\n  }\n\n  static closeConnection(){\n    if(connection){\n      close()\n    }\n  }\n}\n"]}